#!/bin/bash

###############################################################################
#
# Close all inherited file handles, except for STDOUT, STDIN, STDERR, and the
# special bash 255 file handle. When starting services, we do not want the
# parent process's file handles to be open within the services' processes.
# Inherited file handles can create several problems:
#
#  1. The calling process could be left waiting for the file handle to be
#     closed. This has caused, for example, ms-cli to hang when restarting
#     proftpd.
#  2. There are potential security implications of leaving file handles open
#     (i.e. opened as root) when spawning a process that will run with
#     restricted (by apparmor) privileges.
#
# From =Advanced Programming in the UNIX Environment= (Section 13.3 - Coding
# Rules (Daemon Processes):
#   > 5. Unneeded file descriptors should be closed.  This prevents the daemon
#        from holding open any descriptors that it may have inherited from its
#        parent (which could be a shell or some other process).
#
# It would be nice if this convention was followed. However, it appears that
# it is not routinely followed, assuming, apparently, that the parent will
# close all file descriptors before forking the daemon process. At a minimum,
# neither nginx nor proftpd follow this convention.
#
# PHP has a related issue that exacerbates this problem:
#   exec() leaks file  and socket descriptors to called program 
#   https://bugs.php.net/bug.php?id=67383
#
# The Direct IO dio_fnctl function, which would allow us to work around the
# PHP issue by setting the appropriate flags on open file handles has been
# removed from PHP since 5.0.5. As such, workarounds are not forthcoming,
# hence this wrapper.
#
# Usage:
#  sanitize service restart example-service
#
###############################################################################


for fd in $(ls /proc/$$/fd); do
  case "$fd" in
    0|1|2|255)
      ;;
    *)
      eval "exec $fd>&-"
      ;;
  esac
done

exec $*
